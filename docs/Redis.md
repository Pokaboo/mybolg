## Redis

### 什么是NoSQL
- Not Only Sql
- 高性能读取
- 高可用
- 存储数据、缓存
- 水平（横向）扩展方便高效

### 分布式缓存
- 提升读取速度性能
- 分布式计算领域
- 降低数据库查询压力
- 跨服务器缓存
- 内存式缓存

### Redis是什么
- Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：
    - 基于内存运行，性能高效
    - 支支持分布式，理论上可以无限扩展
    - key-value存储系统
    - 开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API
- Redis 的应用场景包括：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统
- Redis提供的数据类型主要分为5种自有类型和一种自定义类型，这5种自有类型包括：String类型、哈希类型、列表类型、集合类型和顺序集合类型。

### 缓存方案对比
- Ehcache
    - 优点：
        - 基于java开发 
        - 基于jvm
        - 简单、轻巧、方便
    - 缺点：
        - 集群不支持
        - 分布式不支持

- Mencache
    - 优点：
        - 简单的key-value存储
        - 内存使用率比较高
        - 多核处理，多线程
    - 缺点：
        - 无法容灾
        - 无法持久化

- Redis
    - 优点：
        - 丰富的数据结构
        - 持久化
        - 内存数据库
        - 主从同步，故障转移
    - 缺点：
        - 单线程
        - 单核 
    
###  阻塞与非阻塞
- IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。
    - BIO:同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。每一个线程守着一个IO通道，当没有IO时这个线程就阻塞着，一旦有IO事件发生，这个线程就开始工作
    - NIO:同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。socket主要的读、写、注册和接受函数，在等待就绪阶段都是非阻塞的，真正的IO操作是同步阻塞的。将每个连接(IO通道)都注册到Selector多路复用器上，告诉复用器我已经连接了，如果有IO事件发生，你就通知我。Selector就不断地调用select函数，去访问每一个通道看那个通道有IO事件发生，如果发生了就通知，内核开启一个对应事件的线程去工作
    - AIO :异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数

### 多路复用器
- 为什么 Redis 中要使用 I/O 多路复用这种技术呢？

  ```
  首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的
  ```


### Redis线程模型
[![cFdOGF.png](https://z3.ax1x.com/2021/03/30/cFdOGF.png)](https://imgtu.com/i/cFdOGF)


### Redis发布与订阅

### Redis持久化
- Redis的持久化机制RDB（Redis DataBase）
    - 1、什么是RDB：每隔一段时间，把内存中的数据写入磁盘的临时文件，作为快照，恢复的时候把快照文件读进内存。如果宕机重启，那么内存里的数据肯定会没有的，那redis后，则会恢复
    - 2、备份与回复
        - 内存备份--->磁盘临时文件
        - 临时文件--->恢复导内存
    - 3、RDB优劣势
        - 优势：
            - 1、每隔一段时间备份，全量备份
            - 2、灾备简单，可以远程传输
            - 3、子进程备份的时候，主进程不会有任何io操作（不会有写入修改或删除），保证备份数据的完整性
            - 相对于AOF来说，当有更大文件的时候可以快速重启恢复           
        - 劣势：
            - 1、 发生故障是，有可能会丢失最后一次的备份数据 
            - 2、子进程所占用的内存比会和父进程一模一样，如会造成CPU负担
            - 3、由于定时全量备份是重量级操作，所以对于实时备份，就无法处理了。
    
- Redis的持久化机制AOF（Append Only File）
[![cMv8nH.png](https://z3.ax1x.com/2021/04/05/cMv8nH.png)](https://imgtu.com/i/cMv8nH)
    - 1、RDB会丢失最后一次备份的rdb文件，但是其实也无所谓，其实也可以忽略不计，毕竟是缓存，丢了就丢了，但是如果追求数据的完整性，那就的考虑使用AOF了
    - 2、AOF特点：
        - 1、以日志的形式来记录用户请求的写操作。读操作不会记录，因为写操作才会存存储。
        - 2、文件以追加的形式而不是修改的形式
        - 3、redis的aof恢复其实就是把追加的文件从开始到结尾读取执行写操作
    - 优劣势：
        - 优势：
            - 1、AOF更加耐用，可以以秒级别为单位备份，如果发生问题，也只会丢失最后一秒的数据，大大增加了可靠性和数据完整性。所以AOF可
一次，使用fsync操作
            - 2、以log日志形式追加，如果磁盘满了，会执行 redis-check-aof 工具
            - 3、当数据太大的时候，redis可以在后台自动重写aof。当redis继续把日志追加到老的文件中去时，重写也是非常安全的，不会影响客户端
作
            - 4、AOF 日志包含的所有写操作，会更加便于redis的解析恢复
        - 劣势：
            - 1、相同的数据，同一份数据，AOF比RDB大
            - 2、针对不同的同步机制，AOF会比RDB慢，因为AOF每秒都会备份做写操作，这样相对与RDB来说就略低。 每秒备份fsync没毛病，但是
的每次写入就做一次备份fsync的话，那么redis的性能就会下降
            - 3、AOF发生过bug，就是数据恢复的时候数据不完整，这样显得AOF会比较脆弱，容易出现bug，因为AOF没有RDB那么简单，但是呢为
的产生，AOF就不会根据旧的指令去重构，而是根据当时缓存中存在的数据指令去做重构，这样就更加健壮和可靠了
    - 到底采用RDB还是AOF呢？
        - 1、如果你能接受一段时间的缓存丢失，那么可以使用RDB
        - 2、如果你对实时性的数据比较care，那么就用AOF 

### 主从复制原理
- 主从复制（读写分离）
[![cMzPL4.png](https://z3.ax1x.com/2021/04/05/cMzPL4.png)](https://imgtu.com/i/cMzPL4)
- 主从模式

### Redis 缓存过期处理与内存淘汰机制
- 计算机内存有限，越大越贵，Redis的高并发高性能都是基于内存的，用硬盘的话GG
- 已过期的key如何处理：虽然key过期了，但是只要没有被redis清理，那么其实内存还是会被占用着的
    - 设置了expire的key缓存过期了，但是服务器的内存还是会被占用，这是因为redis所基于的两种删除策略，edis有两种策略：
        - 1. （主动）定时删除：定时随机的检查过期的key，如果过期则清理删除。（每秒检查次数在redis.conf中的hz配置）
        - 2. （被动）惰性删除：当客户端请求一个已经过期的key的时候，那么redis会检查这个key是否过期，如果过期了，则删除，然后返回一个nil。这种策略
友好，不会有太多的损耗，但是内存占用会比较高。
- 那么如果内存被Redis缓存占用慢了咋办？redis提供了一套缓存淘汰机制：MEMORY MANAGEMENT

### Redis 的哨兵模式
- 问题：Master挂了，如何保证可用性，实现继续读写？
- 什么是哨兵：Sentinel(哨兵)是用于监控Redis集群中Master状态的工具，是 Redis 高可用解决方案，哨兵可以监视一个或者多个redis master服务，以及这些master服务的所有某个master服务宕机后，会把这个master下的某个从服务升级为master来替代已宕机的master继续工作。
- 原Master恢复后不同步问题：Master恢复成Slave后，他的同步状态不OK，状态为master_link_status:down ，这是为什么呢？
    - 1. 网络通信问题，要保证互相ping通，内网互通
    - 2. 关闭防火墙，对应的端口开发（虚拟机中建议永久关闭防火墙，云服务器的话需要保证内网互通）。
    - 3. 统一所有的密码，不要漏了某个节点没有设置。

### Redis 集群
- 1. 每个节点知道彼此之间的关系，也会知道自己的角色，当然他们也会知道自己存在与一个集群环境中，他们彼此之间可以交互和通信，ong。那么这些关系都会保存到某个配置文件中，每个节点都有，这个我们在搭建的时候会做配置的。
- 2. 客户端要和集群建立连接的话，只需要和其中一个建立关系就行。
- 3. 某个节点挂了，也是通过超过半数的节点来进行的检测，客观下线后主从切换，和我们之前在哨兵模式中提到的是一个道理。
- 4. Redis中存在很多的插槽，又可以称之为槽节点，用于存储数据，这个先不管，后面再说。

### 集群容错
- 构建Redis集群，需要至少3个节点作为master，以此组成一个高可用的集群，此外每个master都需要配备一个slave，所以整个集群需要6个节点，这也是最经典集群，也可以称之为三主三从，容错性更佳。
